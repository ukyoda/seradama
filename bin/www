#!/usr/bin/env node
var debug = require('debug')('sera-dev2');
var app = require('../app');
var engine = require('./gameEngine');
var net = require('./gameInterface');
var tools = require('./tools');

var stages = [];
stages[0] = require('../stage/stage1.json');

var message = require('../message/time_up.json');

var fs = require('fs');
fs.readdir('./stage', function(err, files){
  for(var i in files){
  	var stage = require('../stage/' + files[i]);
  	stages.push(stage);
  }
});

if(!fs.existsSync("best_time.json")){
  fs.writeFile('./best_time.json', JSON.stringify({}));
}

var player_textures = require('../public/texture/player.json');
var player_texture_names = [];
var p_t_n_count = 0;
for(var i in player_textures.frames){
  player_texture_names[p_t_n_count] = i;
  p_t_n_count++;
}

var objs = {};
var goals = {};
var kabes = {};
var message_dot = {};
var userCount = 0;

app.set('port', process.env.PORT || 80);

var server = app.listen(app.get('port'), function() {
  debug('Express server listening on port ' + server.address().port);
});

var startTime = 0;
var maxTime = 30000;
var initPoint = {};
initPoint.x = 0.0;
initPoint.y = 0.0;

var stageName = "";

// 世界
var world = engine.createWorld(0.0, 0.0, true);

// 平行世界
var funnyWorld = engine.createWorld(0.0, -10.0, true);

// add start
var socketIO = require('socket.io');
var io = socketIO.listen(server);
io.set("log level", 2);

var getPosition = function(data) {
	rotation = event.rotation;
};

// クライアントが接続してきたときの処理
io.sockets.on('connection', function(socket) {
  console.log("connection");

  // ステージデータ送信
  var msgs = [];
  for(var i in kabes){
    var sendData = net.makeSendData(kabes[i], 'object');
    msgs.push(sendData);
  }
  // ゴールデータ送信
  for(var i in goals){
    var sendData = net.makeSendData(goals[i], 'object');
    msgs.push(sendData);
  }
  // ユーザデータ送信(画像付き)   
  for(var i in objs){
    var sendData = net.makeSendData(objs[i], 'player', objs[i].m_userData.picture);
    msgs.push(sendData);
  }
  // ベストタイム
  var bestTimes = require('../best_time.json');
  if(bestTimes[stageName]){
    var sendData = net.makeSendData(bestTimes[stageName], 'bestTime');
    msgs.push(sendData);
  }else{
    var sendData = {datatype:"bestTime", time:"99:99:99.999"};
    msgs.push(sendData);
  }
  // メッセージデータ送信
  for(var i in message_dot){
    var sendData = net.makeSendData(message_dot[i], 'object');
    msgs.push(sendData);
  }

  // メッセージ送信
  socket.emit('message', {value: msgs});

  // メッセージを受けたときの処理
  socket.on('message', function(data) {
    var obj = objs[socket.id];
    if(data.name){
      if(data.picture){
        // ころころ追加
        var msgs = [];
        userCount++;
        data.id = "ball_" + userCount;
        data.texture = player_texture_names[Math.floor(Math.random() * p_t_n_count)];
        var corocoro = engine.createNewCorocoro(data, world, 'player');
        objs[socket.id] = corocoro;
        var sendData = net.makeSendData(corocoro, 'you', data.picture);
        msgs.push(sendData);
        // メッセージ送信
        socket.emit('message', {value: msgs});

        // 全体に送信
        var sendAll = net.makeSendData(corocoro, 'player', data.picture);
        var msgsAll = [];
        msgsAll.push(sendAll);
        io.sockets.emit('message', {value: msgsAll});

        // ボールを初期位置へ 
        engine.setPlayerPositionWithRandom(corocoro, initPoint.x, initPoint.y);

      }
    }else if(data.gravity){
      if(obj){
        //
      }else{
        return;
      }
      // ボールにユーザーのGravityを反映 
      engine.applyUserGravity(obj, data.gravity.x, data.gravity.y);
    }
  });

  // クライアントが切断したときの処理
  socket.on('disconnect', function(){
    console.log("disconnect:" + socket.id);
    delObj = objs[socket.id];
    if(delObj){
      var sendData = net.makeSendDeleteData(delObj, 'player');
      var msgs = [];
      msgs.push(sendData);
      delete objs[socket.id];
      io.sockets.emit('message', {value: msgs});
      world.DestroyBody(delObj);
    }
  });
});

function makeStage(){
  var stage = stages[Math.floor(Math.random() * stages.length)];
  // メモリリーク起きる？
  kabes = {};
  goals = {};

  for(var i in stage){
    var stageObj = stage[i];

    switch(stageObj.datatype){
      case 'goal':
        // ゴール配置
        goals[stageObj.id] = engine.createStaticObj(stageObj, world, stageObj.datatype);
        break;
      case 'kabe':
        // 障害物追加
        kabes[stageObj.id] = engine.createStaticObj(stageObj, world, stageObj.datatype);
        break;
      case 'initPoint':
        // ボール初期位置設定
        initPoint = {x:stageObj.x, y:stageObj.y};
        break;
      case 'stageName':
        // すてーじねーむ
        stageName = stageObj.name;
        break;
      default:
        break;
    }

    // ボールを初期位置へ
    for(var i in objs){
      engine.setPlayerPositionWithRandom(objs[i], initPoint.x, initPoint.y);
    }

  }
  startTime = new Date();
}
makeStage();

// 精度
var iterations = 10;
var fps = 15;
var interval;

function mainLoop() {
  interval = setInterval(function() {
    world.Step(1.0/fps, iterations);
    funnyWorld.Step(1.0/fps, iterations);
    var msgs = [];
    var sendData = {};

    // タイムアウト判定
    if((new Date() - startTime) > maxTime){
      startTime = new Date();

      // メッセージ
      for(var i in message_dot){
        // オブジェクト削除
        sendData = net.makeSendDeleteData(message_dot[i], 'object');
        msgs.push(sendData);
        funnyWorld.DestroyBody(message_dot[i]);
        delete message_dot[i];
      }
      for(var i in message){
        var messageObj = message[i];
        message_dot[messageObj.id] = engine.createNewDynamicObjBox(messageObj, funnyWorld, 'object');
        engine.collapseMessage(message_dot[messageObj.id]);
      }

      // ボール位置を初期位置へ  
      for(var i in objs){
        engine.setPlayerPositionWithRandom(objs[i], initPoint.x, initPoint.y);
      }
    }

    // 3秒でメッセージ削除
    if(tools.getPastTime(startTime) > 3000){
      for(var i in message_dot){
        // オブジェクト削除
        sendData = net.makeSendDeleteData(message_dot[i], 'object');
        msgs.push(sendData);
        funnyWorld.DestroyBody(message_dot[i]);
        delete message_dot[i];
      }
    }  
    
    // ゴール判定
    for(var i in goals){
      contact = goals[i].m_contactList;
      if(contact){
        break;
      }
    }
    if(contact){
      // ベストタイム系処理
      if(startTime > 0){
        var nowTime = new Date();
        var pastTime = nowTime - startTime;
        var bestTimes = require('../best_time.json');
        if(bestTimes[stageName]){
          var bestTime = bestTimes[stageName].time;
          if(parseInt(bestTime) > parseInt(pastTime)){
            bestTimes[stageName] = {time:pastTime, userName:contact.other.m_userData.name, userType:contact.other.m_userData.userType};
            fs.writeFile('./best_time.json', JSON.stringify(bestTimes));
          }
        }else{
          bestTimes[stageName] = {time:pastTime, userName:contact.other.m_userData.name, userType:contact.other.m_userData.userType};
          fs.writeFile('./best_time.json', JSON.stringify(bestTimes));
        }
      }

      // ランキング処理
      contact.other.m_userData.win += 1;
      var ranking = new Array();
      for(var i in objs){
        var rank = {id:objs[i].m_userData.id, win:objs[i].m_userData.win};
        ranking.push(rank);
      }
      ranking.sort(
        function(a,b){
          return b.win - a.win;
        }
      );
      sendData = {datatype:"ranking", data:ranking, win_id:contact.other.m_userData.id};
      msgs.push(sendData);

      // ステージ削除
      for(var i in kabes){
        sendData = net.makeSendDeleteData(kabes[i], 'object');
        msgs.push(sendData);
        world.DestroyBody(kabes[i]);
      }
      // ゴール削除
      for(var i in goals){
        sendData = net.makeSendDeleteData(goals[i], 'object');
        msgs.push(sendData);
        world.DestroyBody(goals[i]);
      }
      // ステージ再作成
      makeStage();
      for(var i in kabes){
        // 障害物送信データ作成
        sendData = net.makeSendData(kabes[i], 'object');
        msgs.push(sendData);
      }
      for(var i in goals){
        // ゴール送信データ作成
        sendData = net.makeSendData(goals[i], 'object');
        msgs.push(sendData);
      }
      // ベストタイム
      var bestTimes = require('../best_time.json');
      if(bestTimes[stageName]){
        sendData = net.makeSendData(bestTimes[stageName], 'bestTime');
        sendData.stageName = stageName;
        msgs.push(sendData);
      }else{
        sendData = {datatype:"bestTime", time:"99:99:99.999", stageName:stageName};
        msgs.push(sendData);
      }
    }
    
    // ボール位置update
    for(var i in objs){
      sendData = net.makeSendData(objs[i], 'player');
      msgs.push(sendData);
    }

    // メッセージ位置update
    for(var i in message_dot){
      sendData = net.makeSendData(message_dot[i], 'object');
      msgs.push(sendData);
    }  

    // 経過時間表示するやつ
    var nowTime = new Date();
    var pastTime = nowTime - startTime;
    sendData = net.makeSendData({time:pastTime, datatype:'time'}, 'time');
    msgs.push(sendData);

    // まとめて送信
    io.sockets.emit('message', {value: msgs});
  }, 1000/fps);
}
mainLoop();

// add end